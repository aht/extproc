fork-exec and pipe with I/O redirection

Design goals:
  * Easy to fork-exec commands, sync. or async.
  * Easy to capture stdout/stderr of children (command substitution)
  * Easy to construct pipelines
  * Easy to express I/O redirections
  * Use short names for easy interactive typing

In effect, make Python more usable as a system shell.

Technically, pc.py is a layer on top of subprocess. The subprocess
module support a rich API but is clumsy for many common use cases,
namely sync/async fork-exec, command substitution and pipelining,
all of which is trivial to do on system shells. [1] [2]

To my knowledge, this is powerful enough to do all things that would
have required using subshells in /bin/sh. [3]  (The implementation
does not double-fork as is done in subshell)

The main interpreter process had better be a single thread, since
forking multithreaded programs is not well understood by mortals. [4]

Doctests require /bin/sh to pass. Tested on Linux.

[1] sh(1)
[2] The Scheme Shell -- http://www.scsh.net/docu/html/man.html
[4] http://tldp.org/LDP/abs/html/subshells.html
[3] http://golang.org/src/pkg/syscall/exec_unix.go


INTRODUCTION
============

run(), spawn() and capture()
----------------------------

Cmd objects hold fork-exec info and can be run(), spawn()'ed or capture()'d.

Cmd.run() performs a fork-exec-wait, e.g.

    >>> Cmd('dmesg').run()

which is equivalent to a "normal" shell command:

    $ dmesg

Sh(cmd, **kwargs) is equivalent to Cmd(['/bin/sh', '-c', cmd], **kwargs)


spawn() performs an fork-exec (asynchronous), e.g.

    >>> Cmd(['gvim', '-f']).spawn()

This is equivalent to shell's ampersand:

    $ gvim -f &


captured() is like run() but could return a subset of the child's
[stdout, stdin] as file object(s), e.g.

    >>> cout = Sh('echo -n foo').capture(1).read()
    >>> cout = Sh('echo -n foo >&2').capture(2).read()
    >>> cout, cerr = Sh('echo -n foo; echo -n bar >&2').capture(1, 2)

This is equivalent to shell backquotes aka command substitution (which
cannot capture stderr separately):

    $ cout=`echo -n foo`
    $ cout=$(echo -n foo; echo -n bar >&2)

cmd(*) returns Cmd(*).capture(1).read() wrapped in a try: ... finally: close() clause.
sh(*) returns Sh(*).capture(1).read() wrapped in a try: ... finally: close() clause.


I/O redirection
---------------

I/O redirections are performed by specifying a dict mapping file
descriptors to either open files, strings, or other file descriptors.

    >>> Sh('echo -n foo; echo -n bar >&2', fd={2: 1}).capture(1).read()

or more succintly,

    >>> sh('echo -n foo; echo -n bar >&2', {2: 1})

You can pass in an open file as well, the following append the child's
stdout to the file 'abc':

    >>> sh('echo -n foo; echo -n bar', {1: open('abc', 'a')})

os.devnull (which is a string) works

    >>> sh('echo bogus stuff', {1: os.devnull})

In fact you can pass in fd=SILIENCE, which send everything straight to
hell, hmm...  I mean /dev/null.

Pipe
----

Pipe are constructed by a list of Cmd's. Pipes can also be run(), spawn()'ed or capture()'d.

    >>> s = Pipe(Cmd('dmesg'), Cmd('/bin/grep x')).capture(1).read()
    
    >>> s = pipe(Cmd('dmesg'), Cmd('/bin/grep x'))


API REFERENCE
=============

See docstrings and doctests for now.
