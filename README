fork-exec and pipe with I/O redirection

Design goals:
  * Easy to fork-exec, capturing child's stdout/stderr or reuse parent's
  * Easy to construct pipelines
  * Easy to express I/O redirections
  * Easy to type

In effect, make Python more usable as a system shell.

Technically, pc.py is a layer on top of subprocess that provides
functionality of tradionally Unix shells.

The main interpreter process had better be a single thread, since
forking multithreaded programs is not well understood by mortals.

Doctests require /bin/sh to pass. Tested on Linux.

This is an alpha release. Some features are unimplemented. Expect bugs.


INTRODUCTION
============

run(), spawn() and capture()
----------------------------

Cmd object hold fork-exec info and can be run(), spawn()'ed or capture()'d.

.

Cmd.run() performs a fork-exec-wait in the shell, e.g.

    >>> Cmd('dmesg').run()

This is equivalent to:

    $ dmesg

run(*) is a shorthand for Cmd(*).run()

.

spawn() performs an fork-exec (asynchronous), e.g.

    >>> Cmd(['gvim', '-f']).spawn()

This is equivalent to shell's ampersand:

    $ gvim -f &

.

captured() is like run() but could return a subset of the child
[stdout, stdin] as a file object, e.g.

    >>> cout = Cmd(['sh', '-c', 'echo -n foo']).capture(1).read()
    >>> cin = Cmd(['sh', '-c', 'echo -n foo >&2']).capture(2).read()
    >>> cin, cout = Cmd(['sh', '-c', 'echo -n foo; echo -n bar >&2']).capture(1, 2)

This is equivalent to shell backquotes aka command substitution (which
can't capture stderr):

    $ cout=`echo -n foo; echo -n bar >&2`
    $ cout=$(echo -n foo; echo -n bar >&2)

cmdout(*) is a shorthand for a careful Cmd(*).capture(1).read() and close().


I/O redirection
---------------

I/O redirection are performed by specifying a dict mapping file
descriptors to either open files, strings, or other file descriptors.

    >>> Cmd(['sh', '-c', 'echo -n foo; echo -n bar >&2'], fd={2: 1}).capture(1).read()

or more succintly,

    >>> cmdout('sh-c "echo -n foo; echo -n bar >&2"', {2: 1})

os.devnull (which is a string) works

    >>> cmdout('sh-c "bogus comand"', {1: os.devnull, 2: os.devnull})

In fact you can pass in the SILIENCE constant, which is a dict where
everything goes straight to hell, hmm...  I meant /dev/null.

Pipe
----

Pipe are constructed by a list of Cmd's. Pipe can also be run(), spawn()'ed or capture()'d.

    >>> s = Pipe(Cmd('dmesg'), Cmd('grep x')).capture(1).read()
    
    >>> s = pipeout(Cmd('dmesg'), Cmd('grep x'))


My mind is a bit blank right now, more example later ...
    

REFERENCE
=========

http://www.scsh.net/docu/html/man.html
http://golang.org/pkg/os/#ForkExec
